import { RPCNetClient } from "../net/socket.io";
import { RPCContent } from "../proto";
import { RPCNetBase } from "./RPCNetBase";
// 这里提供rpc接口服务
export class RPCRequest extends RPCNetBase {
    genRPC = 0;
    protected makeRequestID(role: string) {
        let id = "R" + role + "P" + process.pid + "I" + this.genRPC++;
        return id;
    }
    mapRPCMap: Map<string, {
        reslove: (v: any) => void;
        reject(err: any): void;
    }> = new Map;
    constructor(role: string, srv?: number | RPCNetClient) {
        super(role, true, srv);
        this.on("RPCRET", this.onRPCBack.bind(this));
    }

    protected onRPCBack(context: RPCContent) {
        let code = context.args[0];
        let callP = this.mapRPCMap.get(context.requestID);
        if (!callP)
            return;
        // 移除请求
        this.mapRPCMap.delete(context.requestID);
        if (code == 0) {
            callP.reslove(context.args[1]);
        }
        else {
            callP.reject({ code: context.args[0], errMsg: context.args[1] });
        }
    }
    /**
     * 提供rpc的调用接口
     * @param dispatchKey 分发时的识别控制id
     * @param route 请求路径
     * @param args 请求参数
     */
    Call<T>(dispatchKey: string, route: string, ...args: any[]): Promise<T> {
        return new Promise((reslove, reject) => {
            let reqId = dispatchKey + '.' + this.makeRequestID(this.role);
            this.send("RPC", reqId, [this.role, route].join("."), ...args);
            this.mapRPCMap.set(reqId, { reslove, reject });
        });
    }
    /**
     * 广播调用，这种就不需要统计返回结果了
     * @param toSelf 是否需要抄送自己
     * @param route
     * @param args
     */
    CallBroadcast(toSelf: boolean, route: string, ...args: any[]) {
        let reqId = this.makeRequestID(this.role);
        this.send("RPCBC", reqId, toSelf, [this.role, route].join("."), ...args);
    }
}
